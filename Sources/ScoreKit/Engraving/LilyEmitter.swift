import Foundation

/// Minimal LilyPond emitter for MVP/testing.
public enum LilyEmitter {
    /// Emit a simple score containing a single voice with given events.
    /// Durations map to Lily as `den` (1,2,4,8,16...).
    public static func emit(events: [Event], title: String? = nil) -> String {
        var lines: [String] = []
        lines.append("% Generated by ScoreKit")
        if let t = title { lines.append("\\header { title = \"\(t)\" }") }
        lines.append("{")
        for e in events {
            switch e {
            case let .note(pitch, dur):
                lines.append("\(lp(pitch))\(ld(dur))")
            case let .rest(dur):
                lines.append("r\(ld(dur))")
            }
        }
        lines.append("}")
        return lines.joined(separator: "\n")
    }

    /// Emit a score from notated events, including slurs, articulations, and hairpins.
    public static func emit(notated events: [NotatedEvent], title: String? = nil) -> String {
        var lines: [String] = []
        lines.append("% Generated by ScoreKit")
        if let t = title { lines.append("\\header { title = \"\(t)\" }") }
        lines.append("{")
        for (i, e) in events.enumerated() {
            switch e.base {
            case let .note(pitch, dur):
                var prefix = ""
                if let dyn = e.dynamic { prefix = "\\\(dyn.rawValue) " }
                var token = prefix + "\(lp(pitch))\(ld(dur))"
                for art in e.articulations { token += articulationSuffix(art) }
                if e.tieStart { token += "~" }
                if e.slurStart { token += "(" }
                if e.slurEnd { token += ")" }
                if let hp = e.hairpinStart { token += hairpinStart(hp) }
                if e.hairpinEnd { token += " \\!" }
                lines.append(token)
            case let .rest(dur):
                var prefix = ""
                if let dyn = e.dynamic { prefix = "\\\(dyn.rawValue) " }
                var token = prefix + "r\(ld(dur))"
                if e.slurStart { token += "(" }
                if e.slurEnd { token += ")" }
                if let hp = e.hairpinStart { token += hairpinStart(hp) }
                if e.hairpinEnd { token += " \\!" }
                lines.append(token)
            }
            _ = i
        }
        lines.append("}")
        return lines.joined(separator: "\n")
    }

    private static func ld(_ d: Duration) -> String {
        // assume powers-of-two denominators common in Lily; fallback to 4
        return String(d.den)
    }

    private static func lp(_ p: Pitch) -> String {
        // Lily note names: c d e f g a b; sharps as 'is', flats as 'es'
        let base: String
        switch p.step {
        case .C: base = "c"
        case .D: base = "d"
        case .E: base = "e"
        case .F: base = "f"
        case .G: base = "g"
        case .A: base = "a"
        case .B: base = "b"
        }
        let acc: String = {
            switch p.alter {
            case 2: return "isis"
            case 1: return "is"
            case -1: return "es"
            case -2: return "eses"
            default: return ""
            }
        }()
        // Middle C (C4) is c'; Lily uses ' for higher octaves, , for lower. Treat C4 as c'.
        let octaveMarks: String = {
            let rel = p.octave - 3 // Lily: middle C (C4) is c'
            if rel > 0 { return String(repeating: "'", count: rel) }
            if rel < 0 { return String(repeating: ",", count: -rel) }
            return ""
        }()
        return base + acc + octaveMarks
    }

    private static func articulationSuffix(_ a: Articulation) -> String {
        switch a {
        case .staccato: return "-."
        case .accent: return "->"
        case .marcato: return "-^"
        case .tenuto: return "-_"
        }
    }

    private static func hairpinStart(_ h: Hairpin) -> String {
        switch h {
        case .crescendo: return " \\<"
        case .decrescendo: return " \\>"
        }
    }
}
