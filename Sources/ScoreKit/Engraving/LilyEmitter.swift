import Foundation

/// Minimal LilyPond emitter for MVP/testing.
public enum LilyEmitter {
    /// Emit a simple score containing a single voice with given events.
    /// Durations map to Lily as `den` (1,2,4,8,16...).
    public static func emit(events: [Event], title: String? = nil) -> String {
        var lines: [String] = []
        lines.append("% Generated by ScoreKit")
        if let t = title { lines.append("\\header { title = \"\(t)\" }") }
        lines.append("{")
        for e in events {
            switch e {
            case let .note(pitch, dur):
                lines.append("\(lp(pitch))\(ld(dur))")
            case let .rest(dur):
                lines.append("r\(ld(dur))")
            }
        }
        lines.append("}")
        return lines.joined(separator: "\n")
    }

    private static func ld(_ d: Duration) -> String {
        // assume powers-of-two denominators common in Lily; fallback to 4
        return String(d.den)
    }

    private static func lp(_ p: Pitch) -> String {
        // Lily note names: c d e f g a b; sharps as 'is', flats as 'es'
        let base: String
        switch p.step {
        case .C: base = "c"
        case .D: base = "d"
        case .E: base = "e"
        case .F: base = "f"
        case .G: base = "g"
        case .A: base = "a"
        case .B: base = "b"
        }
        let acc: String = {
            switch p.alter {
            case 2: return "isis"
            case 1: return "is"
            case -1: return "es"
            case -2: return "eses"
            default: return ""
            }
        }()
        // Middle C (C4) is c'; Lily uses ' for higher octaves, , for lower. Treat C4 as c'.
        let octaveMarks: String = {
            let rel = p.octave - 4 // relative to 4
            if rel > 0 { return String(repeating: "'", count: rel) }
            if rel < 0 { return String(repeating: ",", count: -rel) }
            return ""
        }()
        return base + acc + octaveMarks
    }
}

